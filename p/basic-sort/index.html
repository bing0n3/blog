<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>基本的排序算法 - bing0ne Base</title><meta name=description content="排序是算法领域重要的组成部分，本文将介绍几种重要的排序。
插入，选择，希尔，归并，快速排序，堆排序等。"><meta name=author content=bing0ne><link href=https://blog.bing0ne.com/an-old-hope.min.css rel=stylesheet><link href=https://blog.bing0ne.com/style.css rel=stylesheet><link rel=apple-touch-icon href=https://blog.bing0ne.com/apple-touch-icon.png><link rel=icon href=https://blog.bing0ne.com/favicon.ico><meta name=generator content="Hugo 0.58.2"><link rel=alternate type=application/atom+xml href=https://blog.bing0ne.com/index.xml title="bing0ne Base"><meta property=og:title content=基本的排序算法><meta property=og:description content="排序是算法领域重要的组成部分，本文将介绍几种重要的排序。
插入，选择，希尔，归并，快速排序，堆排序等。"><meta property=og:type content=article><meta property=og:url content=https://blog.bing0ne.com/p/basic-sort/><meta property=article:published_time content=2016-08-26T18:27:24+08:00><meta property=article:modified_time content=2016-08-26T18:27:24+08:00></head><body class=single><header class=header><nav class=nav><p class=logo><a href=https://blog.bing0ne.com>bing0ne Base</a></p><ul class=menu><li><a href=https://blog.bing0ne.com/>Home</a></li><li><a href=https://blog.bing0ne.com/categories/dev/>Dev</a></li><li><a href=https://blog.bing0ne.com/categories/eassy/>Eassy</a></li><li><a href=https://blog.bing0ne.com/categories/gsoc/>GSoC</a></li><li><a href=https://blog.bing0ne.com/tags/>Tags</a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>基本的排序算法</h1><div class=post-meta>bing0ne · August 26, 2016</div></header><div class=post-content><p>排序是算法领域重要的组成部分，本文将介绍几种重要的排序。
插入，选择，希尔，归并，快速排序，堆排序等。</p><p>下面的排序算法都在排序类模板下实现。</p><p><strong>模板如下</strong></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#a6e22e>class</span> SortExample {

    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sort</span>(Comparable[] <span style=color:#a6e22e>a</span>) {

    }

    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>static</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>less</span>(Comparable <span style=color:#a6e22e>v</span>, Comparable <span style=color:#a6e22e>w</span>) {
        <span style=color:#66d9ef>return</span> v.<span style=color:#a6e22e>compareTo</span>(w) <span style=color:#f92672>&lt;</span> 0;
    }

    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>exch</span>(Comparable[] <span style=color:#a6e22e>a</span>,<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>i</span>, <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>j</span>) {
        Comparable <span style=color:#a6e22e>t</span> <span style=color:#f92672>=</span> a[i];
        a[i] <span style=color:#f92672>=</span> a[j];
        a[j] <span style=color:#f92672>=</span> t;
    }

    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>show</span>(Comparable[] <span style=color:#a6e22e>a</span>) {
        <span style=color:#66d9ef>for</span> (Comparable <span style=color:#a6e22e>v</span> <span style=color:#f92672>=</span> a) {
            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>print</span>(v <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; &#34;</span>);
        }
        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>();
    }

    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>static</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isSorted</span>(Comparable[] <span style=color:#a6e22e>a</span>) {
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> 1; i <span style=color:#f92672>&lt;</span> a.<span style=color:#a6e22e>length</span>; i<span style=color:#f92672>++</span>) {
            <span style=color:#66d9ef>if</span>(less(a[i],a[i<span style=color:#f92672>-</span>1])) {
                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
            }
        }

        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
    }

}</code></pre></div><h1 id=选择排序>选择排序</h1><p>选择排序相对简单,每次从队列中选出最小的数，然后与第一个元素交换，然后再从剩下的数组中找出最小的，然后和第二个元素交换，以此类推。</p><p><strong>实现</strong></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#a6e22e>class</span> SelectSort <span style=color:#a6e22e>extends</span> SortExample{
    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sort</span>(Comparable[] <span style=color:#a6e22e>a</span>) {

        <span style=color:#75715e>//数组长度
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>N</span><span style=color:#f92672>:</span> a.<span style=color:#a6e22e>length</span>;

        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> N; i<span style=color:#f92672>++</span>) {
            <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>min</span> <span style=color:#f92672>=</span> i;
            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>j</span> <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> 1; j <span style=color:#f92672>&lt;</span> N; j<span style=color:#f92672>++</span>){
                <span style=color:#66d9ef>if</span>(less(a[j],a[min])) {
                    min <span style=color:#f92672>=</span> j;
                }
            }

            exch(a,min,i);
        }
    }

}</code></pre></div><h1 id=插入排序>插入排序</h1><p>人们整理扑克牌时，通常一张一张抽取，然后将排插入已有牌中的适当位置。插入排序的实现类似于次，从数组中按顺序选取元素，然后插入，在这过程中我们可能需要向右移动已排序好的元素。</p><p><strong>实现</strong></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#a6e22e>class</span> InsertSort <span style=color:#a6e22e>extends</span> SortExample {
    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sort</span>(Comparable[] <span style=color:#a6e22e>a</span>) {
        <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>N</span><span style=color:#f92672>:</span> a.<span style=color:#a6e22e>length</span>; <span style=color:#75715e>// 数组长度
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> 1; i <span style=color:#f92672>&lt;</span> N; i<span style=color:#f92672>++</span>) {
            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>j</span> <span style=color:#f92672>=</span> i; j <span style=color:#f92672>&gt;</span> 0 <span style=color:#f92672>&amp;&amp;</span> less(a[j],a[j<span style=color:#f92672>-</span>1]); j<span style=color:#f92672>--</span>) {
                exch(a, j, j<span style=color:#f92672>-</span>1);
            }
        }
    }
}</code></pre></div><h1 id=希尔排序>希尔排序</h1><p>这是一种基于插入排序的快速排序。对于大规模的乱序数组来说插入排序的速度很慢，因为他只交换相邻的元素。
shell的核心思想是数组中任意间隔h的元素是有序的。在排序时如果h很大，便能实现，元素远距离的交换。</p><p><strong>实现</strong></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#a6e22e>class</span> ShellSort <span style=color:#a6e22e>extends</span> SortExample {
    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sort</span>(Comparable[] <span style=color:#a6e22e>a</span>) {

        <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>N</span> <span style=color:#f92672>=</span> a.<span style=color:#a6e22e>length</span>;
        <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>h</span> <span style=color:#f92672>=</span> 1;

        <span style=color:#66d9ef>while</span> (h <span style=color:#f92672>&lt;</span> N<span style=color:#f92672>/</span>3) {
            h <span style=color:#f92672>=</span> 3 <span style=color:#f92672>*</span> h <span style=color:#f92672>+</span> 1;
        }

        <span style=color:#66d9ef>while</span> (h <span style=color:#f92672>&gt;=</span> 1) {
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> h; i <span style=color:#f92672>&lt;</span> N; i<span style=color:#f92672>++</span>) {
                <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>j</span> <span style=color:#f92672>=</span> i; j <span style=color:#f92672>&gt;=</span> h <span style=color:#f92672>&amp;&amp;</span> less(a[j],a[j<span style=color:#f92672>-</span>h]);j <span style=color:#f92672>-=</span> h) {
                    exch(a,j,j<span style=color:#f92672>-</span>h);
                }
            }

            h: h<span style=color:#f92672>/</span>3 ;

        }
    }
}</code></pre></div><h1 id=归并排序>归并排序</h1><p>归并排序是一个利用分治思想的排序，它将一个问题缩小来解决问题。归并有两种实现，一种是自顶向下的，一种是自底向上的。两种方法的实现不同，但核心思想都是将问题缩小。</p><p><strong>自顶向下</strong></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=color:#66d9ef>public</span> <span style=color:#a6e22e>class</span> MergeSort <span style=color:#a6e22e>extends</span> SortExample {
    <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>static</span> Comparable[] <span style=color:#a6e22e>aux</span>;

   <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sort</span>(Comparable[] <span style=color:#a6e22e>a</span>) {
        aux<span style=color:#f92672>:</span> <span style=color:#66d9ef>new</span> Comparable[a.<span style=color:#a6e22e>length</span>];
       sort(a,0,a.<span style=color:#a6e22e>length</span> <span style=color:#f92672>-</span>1);
       <span style=color:#66d9ef>assert</span>(isSorted(a));
   }
    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sort</span>(Comparable[] <span style=color:#a6e22e>a</span>, <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>lo</span>, <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>hi</span>){
        <span style=color:#66d9ef>if</span>( hi <span style=color:#f92672>&lt;=</span> lo) {
            <span style=color:#66d9ef>return</span>;
        }

        <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>mid</span><span style=color:#f92672>:</span> lo <span style=color:#f92672>+</span> (hi <span style=color:#f92672>-</span> lo)<span style=color:#f92672>/</span>2;
        sort(a,lo,mid);
        sort(a,mid <span style=color:#f92672>+</span> 1, hi);
        <span style=color:#66d9ef>if</span>(less(a[mid <span style=color:#f92672>+</span> 1],a[mid])){
            merge(a, lo, mid, hi);
        }
    }

    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>merge</span>(Comparable[] <span style=color:#a6e22e>a</span>, <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>lo</span>,<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>mid</span>, <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>hi</span>) {
        <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> lo, j <span style=color:#f92672>=</span> mid <span style=color:#f92672>+</span> 1;

        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>k</span> <span style=color:#f92672>=</span> lo; k <span style=color:#f92672>&lt;=</span> hi; k<span style=color:#f92672>++</span>) {
           aux[k] <span style=color:#f92672>=</span> a[k];
        }

       <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>k</span> <span style=color:#f92672>=</span> lo; k <span style=color:#f92672>&lt;=</span> hi; k<span style=color:#f92672>++</span>) {
           <span style=color:#66d9ef>if</span>(i <span style=color:#f92672>&gt;</span>  mid) {
               a[k] <span style=color:#f92672>=</span> aux[j<span style=color:#f92672>++</span>];
           } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>(j <span style=color:#f92672>&gt;</span> hi) {
               a[k] <span style=color:#f92672>=</span> aux[i<span style=color:#f92672>++</span>];
           } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>(less(aux[i],aux[j])) {
               a[k] <span style=color:#f92672>=</span> aux[i<span style=color:#f92672>++</span>];
           } <span style=color:#66d9ef>else</span> {
                a[k] <span style=color:#f92672>=</span> aux[j<span style=color:#f92672>++</span>];
           }
       }
    }
}</code></pre></div><p><strong>自底向上</strong></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#a6e22e>class</span> MergeSortBU <span style=color:#a6e22e>extends</span> SortExample {
    <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>static</span> Comparable[] <span style=color:#a6e22e>aux</span>;

    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sort</span>(Comparable[] <span style=color:#a6e22e>a</span>) {
        <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>N</span><span style=color:#f92672>:</span> a.<span style=color:#a6e22e>length</span>;
        aux<span style=color:#f92672>:</span> <span style=color:#66d9ef>new</span> Comparable[N];

        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>sz</span> <span style=color:#f92672>=</span> 1; sz <span style=color:#f92672>&lt;</span> N; sz <span style=color:#f92672>=</span> sz <span style=color:#f92672>+</span> sz) {
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>lo</span><span style=color:#f92672>=</span> 0; lo <span style=color:#f92672>&lt;</span> N <span style=color:#f92672>-</span> sz; lo <span style=color:#f92672>+=</span> sz <span style=color:#f92672>+</span> sz) {
                merge(a, lo, lo <span style=color:#f92672>+</span> sz <span style=color:#f92672>-</span> 1, Math.<span style=color:#a6e22e>min</span>(lo <span style=color:#f92672>+</span> sz <span style=color:#f92672>+</span> sz <span style=color:#f92672>-</span> 1, N <span style=color:#f92672>-</span> 1));
            }
        }
    }

    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>merge</span>(Comparable[] <span style=color:#a6e22e>a</span>, <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>lo</span>, <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>mid</span>, <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>hi</span>) {
        <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> lo, j <span style=color:#f92672>=</span> mid <span style=color:#f92672>+</span> 1;

        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>k</span> <span style=color:#f92672>=</span> lo; k <span style=color:#f92672>&lt;=</span> hi; k<span style=color:#f92672>++</span>) {
            aux[k] <span style=color:#f92672>=</span> a[k];
        }

        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>k</span> <span style=color:#f92672>=</span> lo; k <span style=color:#f92672>&lt;=</span> hi; k<span style=color:#f92672>++</span>) {
            <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>&gt;</span> mid) {
                a[k] <span style=color:#f92672>=</span> aux[j<span style=color:#f92672>++</span>];
            } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (j <span style=color:#f92672>&gt;</span> hi) {
                a[k] <span style=color:#f92672>=</span> aux[i<span style=color:#f92672>++</span>];
            } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (less(aux[i], aux[j])) {
                a[k] <span style=color:#f92672>=</span> aux[i<span style=color:#f92672>++</span>];
            } <span style=color:#66d9ef>else</span> {
                a[k] <span style=color:#f92672>=</span> aux[j<span style=color:#f92672>++</span>];
            }
        }
    }

}</code></pre></div><p>对于归并排序还有一种改进，就是当子问题的规模足够小时改用插入排序，来结合两者优点，提高效率。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#a6e22e>class</span> MergeXSort <span style=color:#a6e22e>extends</span> SortExample{
    <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>static</span> Comparable[] <span style=color:#a6e22e>aux</span>;

    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sort</span>(Comparable[] <span style=color:#a6e22e>a</span>) {
        aux<span style=color:#f92672>:</span> <span style=color:#66d9ef>new</span> Comparable[a.<span style=color:#a6e22e>length</span>];
        sort(a,0,a.<span style=color:#a6e22e>length</span> <span style=color:#f92672>-</span>1);
        <span style=color:#66d9ef>assert</span>(isSorted(a));
    }
    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sort</span>(Comparable[] <span style=color:#a6e22e>a</span>, <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>lo</span>, <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>hi</span>){
        <span style=color:#66d9ef>if</span>( hi <span style=color:#f92672>&lt;=</span> lo) {
            <span style=color:#66d9ef>return</span>;
        }
        <span style=color:#66d9ef>if</span>(hi <span style=color:#f92672>-</span>lo <span style=color:#f92672>&gt;</span>15) {
            <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>mid</span> <span style=color:#f92672>=</span> lo <span style=color:#f92672>+</span> (hi <span style=color:#f92672>-</span> lo) <span style=color:#f92672>/</span> 2;
            sort(a, lo, mid);
            sort(a, mid <span style=color:#f92672>+</span> 1, hi);
            <span style=color:#66d9ef>if</span>(less(a[mid <span style=color:#f92672>+</span> 1],a[mid])){
                merge(a, lo, mid, hi);
            }
        } <span style=color:#66d9ef>else</span> {

            insert(a,lo,hi);
            <span style=color:#66d9ef>return</span>;
        }

    }

    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>merge</span>(Comparable[] <span style=color:#a6e22e>a</span>, <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>lo</span>,<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>mid</span>, <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>hi</span>) {
        <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:</span> lo, j<span style=color:#f92672>:</span> mid <span style=color:#f92672>+</span> 1;

        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>k</span><span style=color:#f92672>:</span> lo; k <span style=color:#f92672>&lt;=</span> hi; k<span style=color:#f92672>++</span>) {
            aux[k]<span style=color:#f92672>:</span> a[k];
        }

        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>k</span><span style=color:#f92672>:</span> lo; k <span style=color:#f92672>&lt;=</span> hi; k<span style=color:#f92672>++</span>) {
            <span style=color:#66d9ef>if</span>(i <span style=color:#f92672>&gt;</span>  mid) {
                a[k]<span style=color:#f92672>:</span> aux[j<span style=color:#f92672>++</span>];
            } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>(j <span style=color:#f92672>&gt;</span> hi) {
                a[k]<span style=color:#f92672>:</span> aux[i<span style=color:#f92672>++</span>];
            } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>(less(aux[i],aux[j])) {
                a[k]<span style=color:#f92672>:</span> aux[i<span style=color:#f92672>++</span>];
            } <span style=color:#66d9ef>else</span> {
                a[k]<span style=color:#f92672>:</span> aux[j<span style=color:#f92672>++</span>];
            }
        }
    }

    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>insert</span>(Comparable[] <span style=color:#a6e22e>a</span>,<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>lo</span>,<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>hi</span>) {
        <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>N</span><span style=color:#f92672>:</span> lo <span style=color:#f92672>-</span> hi <span style=color:#f92672>+</span> 1; <span style=color:#75715e>// 数组长度
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>i</span><span style=color:#f92672>:</span> lo; i <span style=color:#f92672>&lt;</span> hi <span style=color:#f92672>+</span> 1; i<span style=color:#f92672>++</span>) {
            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>j</span><span style=color:#f92672>:</span> i; j <span style=color:#f92672>&gt;</span> 0 <span style=color:#f92672>&amp;&amp;</span> less(a[j],a[j<span style=color:#f92672>-</span>1]); j<span style=color:#f92672>--</span>) {
                exch(a, j, j<span style=color:#f92672>-</span>1);
            }
        }
    }

}</code></pre></div><h1 id=快速排序>快速排序</h1><p>快速排序是当今使用最广泛的排序算法之一。它的空间复杂度和时间复杂度都十分的优秀，这是别的排序算法所不具备的优势。
快速排序是一种分治的排序算法。将数组一份为二，将有序的子数组归并以使得整个数组有序。
归并排序使用切分，将数组一分为二，使得一边的数组都小于切分的元素，一别的数组都大于切分的元素。递归地调用切分，来排序。</p><p><strong>实现</strong></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#a6e22e>class</span> QuickSort <span style=color:#a6e22e>extends</span> SortExample {
    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sort</span>(Comparable[] <span style=color:#a6e22e>a</span>){
        shuffleArray(a);
        sort(a,0,a.<span style=color:#a6e22e>length</span><span style=color:#f92672>-</span>1);
    }

    <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sort</span>(Comparable[] <span style=color:#a6e22e>a</span>, <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>lo</span>, <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>hi</span>) {

        <span style=color:#66d9ef>if</span>(lo <span style=color:#f92672>&gt;=</span> hi) {
            <span style=color:#66d9ef>return</span>;
        }
        <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>j</span><span style=color:#f92672>:</span> partition(a,lo,hi);
        sort(a,lo,j <span style=color:#f92672>-</span> 1);
        sort(a,j <span style=color:#f92672>+</span> 1,hi);
    }

    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>partition</span>(Comparable[] <span style=color:#a6e22e>a</span>, <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>lo</span>, <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>hi</span>) {

        <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>i</span><span style=color:#f92672>:</span> lo, j<span style=color:#f92672>:</span> hi <span style=color:#f92672>+</span> 1;
        Comparable <span style=color:#a6e22e>v</span><span style=color:#f92672>:</span> a[lo];

        <span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
            <span style=color:#66d9ef>while</span> (less(a[<span style=color:#f92672>++</span>i],v)) <span style=color:#66d9ef>if</span>(i <span style=color:#f92672>==</span> hi) <span style=color:#66d9ef>break</span>;
            <span style=color:#66d9ef>while</span> (less(v,a[<span style=color:#f92672>--</span>j])) <span style=color:#66d9ef>if</span> (j <span style=color:#f92672>==</span> lo) <span style=color:#66d9ef>break</span>;
            <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>&gt;=</span> j) <span style=color:#66d9ef>break</span>;
            exch(a,i,j);
        }
        exch(a,lo,j);

        <span style=color:#66d9ef>return</span> j;
    }

    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>shuffleArray</span>(Comparable[] <span style=color:#a6e22e>ar</span>)
    {
        <span style=color:#75715e>// If running on Java 6 or older, use `new Random()` on RHS here
</span><span style=color:#75715e></span>        Random <span style=color:#a6e22e>rnd</span><span style=color:#f92672>:</span> ThreadLocalRandom.<span style=color:#a6e22e>current</span>();
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>i</span><span style=color:#f92672>:</span> ar.<span style=color:#a6e22e>length</span> <span style=color:#f92672>-</span> 1; i <span style=color:#f92672>&gt;</span> 0; i<span style=color:#f92672>--</span>)
        {
            <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>index</span><span style=color:#f92672>:</span> rnd.<span style=color:#a6e22e>nextInt</span>(i <span style=color:#f92672>+</span> 1);
            <span style=color:#75715e>// Simple swap
</span><span style=color:#75715e></span>            Comparable <span style=color:#a6e22e>a</span><span style=color:#f92672>:</span> ar[index];
            ar[index]<span style=color:#f92672>:</span> ar[i];
            ar[i]<span style=color:#f92672>:</span> a;
        }
    }
}</code></pre></div><h2 id=三向切分的快速排序>三向切分的快速排序</h2><p><strong>实现</strong></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#a6e22e>class</span> Quick3way <span style=color:#a6e22e>extends</span> SortExample {
    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sort</span>(Comparable[] <span style=color:#a6e22e>a</span>){
        shuffleArray(a);
        sort(a,0,a.<span style=color:#a6e22e>length</span><span style=color:#f92672>-</span>1);
    }

    <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sort</span>(Comparable[] <span style=color:#a6e22e>a</span>, <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>lo</span>, <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>hi</span>) {
        <span style=color:#66d9ef>if</span> (hi <span style=color:#f92672>&lt;=</span> lo) {
            <span style=color:#66d9ef>return</span>;
        }

        <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>lt</span> <span style=color:#f92672>=</span> lo,i<span style=color:#f92672>:</span> lo <span style=color:#f92672>=</span> 1, gt<span style=color:#f92672>:</span> hi;
        Comparable <span style=color:#a6e22e>v</span><span style=color:#f92672>:</span> a[lo];

        <span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&lt;=</span> gt) {
            <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>cmp</span><span style=color:#f92672>:</span> a[i].<span style=color:#a6e22e>compareTo</span>(v);

            <span style=color:#66d9ef>if</span>(cmp <span style=color:#f92672>&lt;</span> 0) {
                exch(a,lt<span style=color:#f92672>++</span>,i<span style=color:#f92672>++</span>);
            } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>( cmp <span style=color:#f92672>&gt;</span> 0) {
                exch(a,i,gt<span style=color:#f92672>--</span>);
            } <span style=color:#66d9ef>else</span> {
                i<span style=color:#f92672>++</span>;
            }
        }

        sort(a,lo,lt<span style=color:#f92672>-</span>1);
        sort(a,gt <span style=color:#f92672>+</span> 1,hi);
    }

}</code></pre></div><h1 id=堆排序>堆排序</h1><p>堆排序很简单，它利用了优先队列的性质，只需要实现优先队列的下沉的算法就可以很容易的实现。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#a6e22e>class</span> HeapSort <span style=color:#a6e22e>extends</span> SortExample{

    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sort</span>(Comparable[] <span style=color:#a6e22e>a</span>) {
        <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>N</span> <span style=color:#f92672>=</span> a.<span style=color:#a6e22e>length</span>;

        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>k</span> <span style=color:#f92672>=</span> N<span style=color:#f92672>/</span>2; k <span style=color:#f92672>&gt;=</span>1 ; k<span style=color:#f92672>--</span> ) {
            sink(a,k,N);
        }

        <span style=color:#66d9ef>while</span> (N <span style=color:#f92672>&gt;</span> 1) {
            HeapSort.<span style=color:#a6e22e>exch</span>(a,1,N<span style=color:#f92672>--</span>);
            HeapSort.<span style=color:#a6e22e>sink</span>(a,1,N);
        }

    }

    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sink</span>(Comparable[] <span style=color:#a6e22e>a</span>, <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>k</span>, <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>N</span>) {
        <span style=color:#66d9ef>while</span> ( k <span style=color:#f92672>*</span> 2 <span style=color:#f92672>&lt;=</span> N) {
            <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>j</span> <span style=color:#f92672>=</span> 2 <span style=color:#f92672>*</span> k;
            <span style=color:#66d9ef>if</span>(j  <span style=color:#f92672>&lt;</span> N <span style=color:#f92672>&amp;&amp;</span> HeapSort.<span style=color:#a6e22e>less</span>(a,j,j<span style=color:#f92672>+</span>1)) j<span style=color:#f92672>++</span>;
            <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>HeapSort.<span style=color:#a6e22e>less</span>(a,k,j)) <span style=color:#66d9ef>break</span>;
            HeapSort.<span style=color:#a6e22e>exch</span>(a,k,j);
            k<span style=color:#f92672>:</span> j;
        }
    }

    <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>static</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>less</span>(Comparable[] <span style=color:#a6e22e>pq</span>, <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>i</span>, <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>j</span>) {
        <span style=color:#66d9ef>return</span> pq[i<span style=color:#f92672>-</span>1].<span style=color:#a6e22e>compareTo</span>(pq[j<span style=color:#f92672>-</span>1]) <span style=color:#f92672>&lt;</span> 0;
    }

    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>exch</span>(Comparable[] <span style=color:#a6e22e>pq</span>, <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>i</span>, <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>j</span>) {
        Comparable <span style=color:#a6e22e>swap</span><span style=color:#f92672>:</span> pq[i<span style=color:#f92672>-</span>1];
        pq[i<span style=color:#f92672>-</span>1]<span style=color:#f92672>:</span> pq[j<span style=color:#f92672>-</span>1];
        pq[j<span style=color:#f92672>-</span>1]<span style=color:#f92672>:</span> swap;
    }


}</code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.bing0ne.com/tags/algo>ALGO</a></li></ul></footer><div id=disqus_thread></div><script>var disqus_shortname='bing0ne';(function(){var d=document,s=d.createElement('script');s.src='https://'+disqus_shortname+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the
<a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></article></main><footer class=footer><span>&copy; 2019 <a href=https://blog.bing0ne.com>bing0ne Base</a></span>
<span>&middot;</span>
<span>Powered by <a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>️</span>
<span>&middot;</span>
<span>Theme️ <a href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>Paper</a></span></footer><script src=https://blog.bing0ne.com/highlight.min.js></script><script>hljs.initHighlightingOnLoad();</script></body></html>