<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    
    <title>红黑二叉查找树 - bing0ne Base</title>
    
    <meta name="description" content="红黑树的算法如雷贯耳，但鉴于一些原因从来没有去研究实现过。
红黑树的实质其实是一个2-3树。他相对于 BST 来说更加的扁平。拥有着更好的查找效率。
对于基于红黑树的符号表的操作的运行时间几乎都是对数级别。">
    <meta name="author" content="bing0ne">
    
    <link href="https://blog.bing0ne.com/an-old-hope.min.css" rel="stylesheet">
    <link href="https://blog.bing0ne.com/style.css" rel="stylesheet">
    
    <link rel="apple-touch-icon" href="https://blog.bing0ne.com/apple-touch-icon.png">
    <link rel="icon" href="https://blog.bing0ne.com/favicon.ico">
    
    <meta name="generator" content="Hugo 0.59.0-DEV" />
    
    <link rel="alternate" type="application/atom+xml" href="https://blog.bing0ne.com/index.xml" title="bing0ne Base">
    
    
    <meta property="og:title" content="红黑二叉查找树" />
<meta property="og:description" content="红黑树的算法如雷贯耳，但鉴于一些原因从来没有去研究实现过。
红黑树的实质其实是一个2-3树。他相对于 BST 来说更加的扁平。拥有着更好的查找效率。
对于基于红黑树的符号表的操作的运行时间几乎都是对数级别。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.bing0ne.com/p/br-tree/" />
<meta property="article:published_time" content="2016-09-16T18:26:26+08:00" />
<meta property="article:modified_time" content="2016-09-16T18:26:26+08:00" />

  </head>
  <body class="single">
    <header class="header">
      <nav class="nav">
        
        <p class="logo"><a href="https://blog.bing0ne.com">bing0ne Base</a></p>
        
        
        <ul class="menu">
          
          <li>
            <a href="https://blog.bing0ne.com/">Home</a>
          </li>
          
          <li>
            <a href="https://blog.bing0ne.com/categories/dev/">Dev</a>
          </li>
          
          <li>
            <a href="https://blog.bing0ne.com/categories/eassy/">Eassy</a>
          </li>
          
          <li>
            <a href="https://blog.bing0ne.com/categories/gsoc/">GSoC</a>
          </li>
          
          <li>
            <a href="https://blog.bing0ne.com/tags/">Tags</a>
          </li>
          
        </ul>
        
      </nav>
    </header>
    <main class="main">


<article class="post-single">
  <header class="post-header">
    <h1 class="post-title">红黑二叉查找树</h1>
    <div class="post-meta">bing0ne · September 16, 2016</div>
  </header>
  <div class="post-content"><p>红黑树的算法如雷贯耳，但鉴于一些原因从来没有去研究实现过。
红黑树的实质其实是一个2-3树。他相对于 BST 来说更加的扁平。拥有着更好的查找效率。
对于基于红黑树的符号表的操作的运行时间几乎都是对数级别。</p>

<h2 id="2-3树">2-3树</h2>

<p>二叉树每个节点至多只能有2个节点，但是在2-3树中我们可以通过把两个结点绑定在一起成一个结点，然后让他拥有3个结点。如图
<img src="https://ww1.sinaimg.cn/large/006tNbRwgy1fe8damkrvsj308n05awei.jpg" alt="" />
<img src="https://ww3.sinaimg.cn/large/006tNbRwgy1fe8ddoc1gkj305n0440su.jpg" alt="" />
由于查找较为简单在这里我们不在赘述了。我们着重讲一讲2-3树的插入操作和删除操作。</p>

<h3 id="插入操作">插入操作</h3>

<p>对于插入操作，我们可以分为以下几种情况:</p>

<ul>
<li>向2- 结点插入新键</li>
<li>向一棵只含有3-结点的树插入新键</li>
<li>向一个父结点为2-结点的3结点插入新键</li>
<li>向一个父结点为3-结点的3结点插入新键</li>
</ul>

<h3 id="向2-结点插入新键">向2- 结点插入新键</h3>

<p>对于这种情况，我们直接插入即可，将这个2-结点 变为3-结点。<br />
 <img src="https://ww3.sinaimg.cn/large/006tNbRwgy1fe8ddzwpaxj306h06paab.jpg" alt="" /></p>

<h3 id="向一棵只含有3-结点的树插入新键">向一棵只含有3-结点的树插入新键</h3>

<p>这棵树已经有了2个键，所以我们可以发现，他没有结点可以给新键来插入。我们可以临时把他插入，使得这个结点变为一个4-结点。对于2-3树，不应该存在4-结点。所以我们为了能使得树保持平衡需要进行变化，即把这个4-结点，变为3个2-结点。<br />
<img src="https://ww3.sinaimg.cn/large/006tNbRwgy1fe8deigjfnj30550520sv.jpg" alt="" /></p>

<h3 id="向一个父结点为2-结点的3结点插入新键">向一个父结点为2-结点的3结点插入新键</h3>

<p>当需要插入的位置为3结点，同时他的父节点是一个二结点时，我们首先也行上一个情况中一样，将新键插入，使得3-结点成为一个临时的4-结点，再分解他，但是这一次，我们不再为中间的键去创造一个新的结点，而是把它插入到父节点中，使得她和父节点重新组成一个新的3-结点。<br />
<img src="https://ww1.sinaimg.cn/large/006tNbRwgy1fe8des0v8sj307v0a3gm7.jpg" alt="" /></p>

<h3 id="向一个父结点为3-结点的3结点插入新键">向一个父结点为3-结点的3结点插入新键</h3>

<p>对于这个情况，我们也是先构造一个4-结点，然后将之分解，中键和父节点组成新的父节点，4-节点。分解，中键提出，然后再按照情况
判断，根据情况处理。<br />
<img src="https://ww3.sinaimg.cn/large/006tNbRwgy1fe8df3dqeoj30680bct9b.jpg" alt="" /> <img src="https://ww3.sinaimg.cn/large/006tNbRwgy1fe8dfee499j305h0bcgm4.jpg" alt="" /></p>

<h2 id="红黑二叉查找树">红黑二叉查找树</h2>

<p>对于红黑树来说他最难的操作，就在于删除和插入两部分，查找相对来说要简单，类似于BST的查找，在这里不赘述。</p>

<p>红黑树具有的性质:</p>

<ul>
<li>红链接均为左链接</li>
<li>没有一个结点同时和两条红链接相连</li>
<li>该树是<strong>完美黑色平衡</strong>的，即任意空链接到根结点的路径上的黑链接数量相同。</li>
</ul>

<h3 id="插入">插入</h3>

<p>对于插入操作，我们同2-3树一样，要分情况来讨论。</p>

<h3 id="向单个2-结点中插入新键">向单个2-结点中插入新键</h3>

<p>如果新键要小于老键，那么我只需要新增一个红的结点即可，把这个结点变为一个3-结点。
如果新键大于老键，我们也增加一个红结点，然后通过旋转将红色的左链接修复。最后我们需要把根节点变为黑色
。</p>

<h3 id="向树底部的2-结点插入新键">向树底部的2-结点插入新键</h3>

<p>类似于上面一种情况。
总是用红链接连接父节点和新的结点。然后通过旋转来进行调整。</p>

<h3 id="向一棵双键树-3-结点-插入新键">向一棵双键树（3-结点）插入新键</h3>

<ol>
<li>当新键大于原树种的两个键的时候，我们只需要将其连到右链接上即可。这时我们需要把链接都由红色变为黑色，黑色变为红色，这一步操作对应的是2-3树中「向一棵只含有3-结点的树插入新键」这种类似的情况，即把临时的4-结点，拆掉，父节点提出，如果是根节点为黑，不是则变为红和上面的部分组成3-结点或者4-结点，再次过程中需要进行调整，调整按照情况进行区分。</li>
<li>如果新键小于原树中的两个键，这样形成了两个连续的红链接，我们需要对上层的红链接进行右旋转，这样我们又回到了情况一。</li>
<li>新键在两个键之间，这样也会有两个红链接产生，一个红左接一个红右，我们需要对红右进行左旋，得到第二种情况。</li>
</ol>

<h3 id="实现">实现</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> <span style="color:#a6e22e">void</span> flipColor(Node <span style="color:#a6e22e">h</span>){}
<span style="color:#66d9ef">private</span> <span style="color:#a6e22e">Node</span> rotateRight(Node <span style="color:#a6e22e">h</span>) {}
<span style="color:#66d9ef">private</span> <span style="color:#a6e22e">Node</span> rotateLeft(Node <span style="color:#a6e22e">h</span>){}


<span style="color:#66d9ef">public</span> <span style="color:#a6e22e">void</span> put(Key <span style="color:#a6e22e">key</span>, Value <span style="color:#a6e22e">val</span>) {
   root<span style="color:#f92672">:</span> put(root, key, val);
   root.<span style="color:#a6e22e">color</span><span style="color:#f92672">:</span> BLACK;
}

<span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Node</span> put(Node <span style="color:#a6e22e">h</span>, Key <span style="color:#a6e22e">key</span>, Value <span style="color:#a6e22e">val</span>) {
   <span style="color:#66d9ef">if</span> (h <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>) {
       <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Node(key, val, 1, RED);
   }

   <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">cmp</span><span style="color:#f92672">:</span> key.<span style="color:#a6e22e">compareTo</span>(h.<span style="color:#a6e22e">key</span>);
   <span style="color:#66d9ef">if</span> (cmp <span style="color:#f92672">&lt;</span> 0) {
       h.<span style="color:#a6e22e">left</span><span style="color:#f92672">:</span> put(h.<span style="color:#a6e22e">left</span>, key, val);
   } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (cmp <span style="color:#f92672">&gt;</span> 0) {
       h.<span style="color:#a6e22e">right</span><span style="color:#f92672">:</span> put(h.<span style="color:#a6e22e">right</span>, key, val);
   } <span style="color:#66d9ef">else</span> {
       h.<span style="color:#a6e22e">val</span><span style="color:#f92672">:</span> val;
   }


   <span style="color:#75715e">//处理第三种情况
</span><span style="color:#75715e"></span>   <span style="color:#66d9ef">if</span> (isRed(h.<span style="color:#a6e22e">right</span>) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>isRed(h.<span style="color:#a6e22e">left</span>)) {
       h<span style="color:#f92672">:</span> rotateLeft(h);
   }
   <span style="color:#75715e">//处理第二种情况
</span><span style="color:#75715e"></span>   <span style="color:#66d9ef">if</span> (isRed(h.<span style="color:#a6e22e">left</span>) <span style="color:#f92672">&amp;&amp;</span> isRed(h.<span style="color:#a6e22e">left</span>.<span style="color:#a6e22e">left</span>)) {
       h<span style="color:#f92672">:</span> rotateRight(h);
   }

   <span style="color:#75715e">//处理第一种情况
</span><span style="color:#75715e"></span>   <span style="color:#66d9ef">if</span> (isRed(h.<span style="color:#a6e22e">left</span>) <span style="color:#f92672">&amp;&amp;</span> isRed(h.<span style="color:#a6e22e">right</span>)) {
       flipColor(h);
   }

   h.<span style="color:#a6e22e">N</span><span style="color:#f92672">:</span> size(h.<span style="color:#a6e22e">left</span>) <span style="color:#f92672">+</span> size(h.<span style="color:#a6e22e">right</span>) <span style="color:#f92672">+</span> 1;
   <span style="color:#66d9ef">return</span> h;
}</code></pre></div>
<h3 id="删除">删除</h3>

<p>删除操作比起插入操作更加的复杂。
我们需要在为了删除结点需要构造一个临时的四结点，这需要我们在查找的过程中沿着查找路径向下进行变换。同事我们也需要为了分解遗留的4-结点沿着查找的路径向上进行变换，来保持树的结构。</p>

<h3 id="删除最小键">删除最小键</h3>

<p>我们先从最小键的删除来开始介绍。
我们可以很容易的看到，从树底部的3-结点删除一个键是很简单的，但是对于2-结点来说并不是如此，因为从2-结点删除会留下一个空键，这样破坏了平衡性，因此我们要对此进行处理，沿着左链接进行向下的变化，来确保当前的结点不是2-结点。</p>

<p>我们分情况来进行讨论。首先我们看根节点</p>

<p>对于根节点有两种情况：</p>

<ol>
<li>一种是根结点是2-结点且他的两个子结点也是2-结点，对于这种情况的处理是简单的，我们只需要直接将其转变为一个4-结点即可。</li>
<li>在另一种情况里，我们需要确保我们的根结点的左子结点不是一个2-结点，如果左子结点是2-结点，我们在必要的时候可以向他右侧结点借一个键。</li>
</ol>

<p>对于上述的第二种情况，我们还要继续去分情况讨论。</p>

<ul>
<li>当前结点的左子结点不是2-结点，完成。</li>
<li>当前结点的左子结点是2-结点，而它（子结点）的兄弟结点不是，那么我们将兄弟结点的一个键移动，到根结点，根节点的最小键移动到左子结点。</li>
<li>如果当前结点的子节点都是2-结点，且其本身不是2-结点，那么我们将左子结点，父节点中的最小键，左子结点最近的兄弟结点合并为一个4-结点,使得父结点从一个3-结点或4-结点变为一个2-结点或3-结点。</li>
</ul>

<h4 id="实现-1">实现</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> <span style="color:#a6e22e">Node</span> moveRedLeft(Node <span style="color:#a6e22e">h</span>) {
   <span style="color:#75715e">//当左右两个结点都是2-结点的时候
</span><span style="color:#75715e"></span>   <span style="color:#75715e">//两种情况，根据 h 有两种情况
</span><span style="color:#75715e"></span>   <span style="color:#75715e">//但是在这里只有一种，因为所有的 h 都肯定是红色的
</span><span style="color:#75715e"></span>   <span style="color:#75715e">//将 h和两个子节点组为一个4-结点
</span><span style="color:#75715e"></span>   <span style="color:#75715e">//h 变为黑色的结点
</span><span style="color:#75715e"></span>   flipColor(h);

   <span style="color:#75715e">//h的右节点是3-结点的情况
</span><span style="color:#75715e"></span>   <span style="color:#75715e">//我们要将右子节点的最小键移动到  h所在的结点
</span><span style="color:#75715e"></span>   <span style="color:#75715e">//根据前面的左右旋转代码 可知 我们无法将两个黑色的结点交换
</span><span style="color:#75715e"></span>   <span style="color:#75715e">//所以我们需要先改变 h 及其子节点的颜色来帮助我们移动右子节点的最小键
</span><span style="color:#75715e"></span>   <span style="color:#66d9ef">if</span>(isRed(h.<span style="color:#a6e22e">right</span>.<span style="color:#a6e22e">left</span>)){
       h.<span style="color:#a6e22e">right</span><span style="color:#f92672">:</span> rotateRight(h.<span style="color:#a6e22e">right</span>);
       h<span style="color:#f92672">:</span> rotateLeft(h);
       <span style="color:#75715e">//当我们将之移动完成后我们需要恢复他的颜色
</span><span style="color:#75715e"></span>       flipColor(h);
   }

   <span style="color:#66d9ef">return</span> h;
}

<span style="color:#66d9ef">public</span> <span style="color:#a6e22e">void</span> deleteMin() {


   <span style="color:#75715e">//如果 root 的 左子节点是2-结点
</span><span style="color:#75715e"></span>   <span style="color:#75715e">//root to  RED
</span><span style="color:#75715e"></span>   <span style="color:#75715e">//这样有便于下面处理的时候简化问题
</span><span style="color:#75715e"></span>   <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>isRed(root.<span style="color:#a6e22e">left</span>) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>isRed(root.<span style="color:#a6e22e">right</span>)) {
       root.<span style="color:#a6e22e">color</span><span style="color:#f92672">:</span> RED;
   }

   root: deleteMin(root);
   <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>isEmpty()) {
       root.<span style="color:#a6e22e">color</span><span style="color:#f92672">:</span> BLACK;
   }

}

<span style="color:#66d9ef">private</span> <span style="color:#a6e22e">Node</span> deleteMin(Node <span style="color:#a6e22e">h</span>) {
   <span style="color:#66d9ef">if</span> (h.<span style="color:#a6e22e">left</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>) {
       <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span>;
   }

   <span style="color:#75715e">//判断左子节点说不是3-结点 进入从右结点借的情况
</span><span style="color:#75715e"></span>   <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>isRed(h.<span style="color:#a6e22e">left</span>) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>isRed(h.<span style="color:#a6e22e">left</span>.<span style="color:#a6e22e">left</span>)) {
       h<span style="color:#f92672">:</span> moveRedLeft(h);
   }
   <span style="color:#66d9ef">return</span> balance(h);
}</code></pre></div>
<h3 id="删除最大值">删除最大值</h3>

<p>删除最大键的操作和删除最小的相仿。也是分情况考虑。
当左右子结点都是2-结点的时候，将之和父节点一起变为4-结点。
当右结点是2-结点，左结点不是的时候，让右节点从左结点接一个最大的键，也就是最亲的兄弟结点。</p>

<h4 id="实现-2">实现</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> <span style="color:#a6e22e">Node</span> moveRedRight(Node <span style="color:#a6e22e">h</span>) {

   <span style="color:#75715e">// 这里是两种情况的合并,一种是左右两个结点都是2-结点,变为4-结点;
</span><span style="color:#75715e"></span>   <span style="color:#75715e">// 另一种是左结点不是从左结点借结点,但是对于这种情况我们也需要这个变化,来帮助我们旋转变化。
</span><span style="color:#75715e"></span>   flipColor(h);

   <span style="color:#75715e">// 当左结点为3-结点
</span><span style="color:#75715e"></span>   <span style="color:#75715e">// 旋转变换
</span><span style="color:#75715e"></span>   <span style="color:#66d9ef">if</span> (isRed(h.<span style="color:#a6e22e">left</span>.<span style="color:#a6e22e">left</span>)) {
       h<span style="color:#f92672">:</span> rotateRight(h);
       flipColor(h);
   }

   <span style="color:#66d9ef">return</span> h;
}

<span style="color:#66d9ef">public</span> <span style="color:#a6e22e">void</span> deleteMax() {
   <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>isRed(root.<span style="color:#a6e22e">left</span>) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>isRed(root.<span style="color:#a6e22e">right</span>)) {
       root.<span style="color:#a6e22e">color</span><span style="color:#f92672">:</span> RED;
   }

   root: deleteMax(root);

   <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>isEmpty()) {
       root.<span style="color:#a6e22e">color</span><span style="color:#f92672">:</span> BLACK;
   }
}

<span style="color:#66d9ef">private</span> <span style="color:#a6e22e">Node</span> deleteMax(Node <span style="color:#a6e22e">h</span>) {


   <span style="color:#75715e">// 当当前结点是3-结点时候,右旋,来方便删除
</span><span style="color:#75715e"></span>   <span style="color:#66d9ef">if</span> (isRed(h.<span style="color:#a6e22e">left</span>)) {
       h<span style="color:#f92672">:</span> rotateRight(h);
   }

   <span style="color:#75715e">// 当当前结点的右节点为 null 说明没有结点比他更大
</span><span style="color:#75715e"></span>   <span style="color:#75715e">// 又因为,我们通过旋转变化使得当前结点的红链接向右,所以直接删除
</span><span style="color:#75715e"></span>   <span style="color:#66d9ef">if</span> (h.<span style="color:#a6e22e">right</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>) {
       <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span>;
   }

   <span style="color:#75715e">//判断当前结点的➡右结点是不是3-结点,如果不是从左结点借
</span><span style="color:#75715e"></span>   <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>isRed(h.<span style="color:#a6e22e">right</span>) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>isRed(h.<span style="color:#a6e22e">right</span>.<span style="color:#a6e22e">left</span>)) {
       h<span style="color:#f92672">:</span> moveRedRight(h);
   }

   h.<span style="color:#a6e22e">right</span><span style="color:#f92672">:</span> deleteMax(h.<span style="color:#a6e22e">right</span>);

   <span style="color:#66d9ef">return</span> balance(h);
}</code></pre></div>
<h3 id="删除操作">删除操作</h3>

<p>有了删除最小和最大的基础，我们可以很容易的得到删除的思路，就是要在查找路径上把结点变换为3/4-结点，以及在完场删除后再恢复。不过有一点区别，删除发生时的借结点，不是问兄弟结点，而是当前结点的分支下的最大或者最小借。</p>

<h4 id="实现-3">实现</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#a6e22e">void</span> delete(Key <span style="color:#a6e22e">key</span>) {

   <span style="color:#75715e">//将根节点变为 red
</span><span style="color:#75715e"></span>   <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>isRed(root.<span style="color:#a6e22e">left</span>) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>isRed(root.<span style="color:#a6e22e">right</span>)) {
       root.<span style="color:#a6e22e">color</span><span style="color:#f92672">:</span> RED;
   }

   root: delete(root, key);

   <span style="color:#75715e">//完成删除恢复根节点为 black，因为红黑树的根节点一定为 black
</span><span style="color:#75715e"></span>   <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>isEmpty()) root.<span style="color:#a6e22e">color</span><span style="color:#f92672">:</span> BLACK;
}

<span style="color:#66d9ef">private</span> <span style="color:#a6e22e">Node</span> delete(Node <span style="color:#a6e22e">h</span>, Key <span style="color:#a6e22e">key</span>) {

   <span style="color:#75715e">//当要删除的键的值小于当前的
</span><span style="color:#75715e"></span>   <span style="color:#75715e">// 进入左边的链接
</span><span style="color:#75715e"></span>   <span style="color:#66d9ef">if</span> (key.<span style="color:#a6e22e">compareTo</span>(h.<span style="color:#a6e22e">key</span>) <span style="color:#f92672">&lt;</span> 0) {<span style="color:#960050;background-color:#1e0010"></span>
   <span style="color:#75715e">//判断左边的子节点是不是2-结点，如果是则要借，这里同删除最小
</span><span style="color:#75715e"></span>       <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>isRed(h.<span style="color:#a6e22e">left</span>) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>isRed(h.<span style="color:#a6e22e">left</span>.<span style="color:#a6e22e">left</span>)) {
           h<span style="color:#f92672">:</span> moveRedLeft(h);
       }
       h.<span style="color:#a6e22e">left</span><span style="color:#f92672">:</span> delete(h.<span style="color:#a6e22e">left</span>, key);
   } <span style="color:#66d9ef">else</span> {
   <span style="color:#75715e">// 相等和大于
</span><span style="color:#75715e"></span>   <span style="color:#75715e">// 当前结点是3-结点。旋转来方便删除
</span><span style="color:#75715e"></span>       <span style="color:#66d9ef">if</span> (isRed(h.<span style="color:#a6e22e">left</span>)) {
           h<span style="color:#f92672">:</span> rotateRight(h);
       }
       <span style="color:#75715e">//当相等时 且右没有 直接删除
</span><span style="color:#75715e"></span>       <span style="color:#66d9ef">if</span> (key.<span style="color:#a6e22e">compareTo</span>(h.<span style="color:#a6e22e">key</span>) <span style="color:#f92672">==</span> 0 <span style="color:#f92672">&amp;&amp;</span> h.<span style="color:#a6e22e">right</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>) {
           <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span>;
       }
       <span style="color:#75715e">//右节点不是3-结点 借结点
</span><span style="color:#75715e"></span>       <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>isRed(h.<span style="color:#a6e22e">right</span>) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>isRed(h.<span style="color:#a6e22e">right</span>.<span style="color:#a6e22e">left</span>)) {
           h<span style="color:#f92672">:</span> moveRedRight(h);
       }
       <span style="color:#75715e">// 如果key 相等找出当前分支的右结点的最小值，记录，deletemin，然后经需要删除的结点
</span><span style="color:#75715e"></span>       <span style="color:#75715e">// 替换为查找到的那个最小结点
</span><span style="color:#75715e"></span>       <span style="color:#66d9ef">if</span> (key.<span style="color:#a6e22e">compareTo</span>(h.<span style="color:#a6e22e">key</span>) <span style="color:#f92672">==</span> 0) {
           h.<span style="color:#a6e22e">val</span><span style="color:#f92672">:</span> get(h.<span style="color:#a6e22e">right</span>, min(h.<span style="color:#a6e22e">right</span>).<span style="color:#a6e22e">key</span>);
           h.<span style="color:#a6e22e">key</span><span style="color:#f92672">:</span> min(h.<span style="color:#a6e22e">right</span>).<span style="color:#a6e22e">key</span>;
           h.<span style="color:#a6e22e">right</span><span style="color:#f92672">:</span> deleteMin(h.<span style="color:#a6e22e">right</span>);
       } <span style="color:#66d9ef">else</span> {
       <span style="color:#75715e">//继续向下寻找
</span><span style="color:#75715e"></span>           h.<span style="color:#a6e22e">right</span><span style="color:#f92672">:</span> delete(h.<span style="color:#a6e22e">right</span>, key);
       }


   }
   <span style="color:#66d9ef">return</span> balance(h);
}</code></pre></div></div>
  
  <footer class="post-footer">
    <ul class="post-tags">
      
      
      <li><a href="https://blog.bing0ne.com/tags/algo">ALGO</a></li>
      
    </ul>
  </footer>
  
  
  
  
  <div id="disqus_thread"></div>
  <script>
    var disqus_shortname = 'bing0ne';
    (function() {
      var d = document, s = d.createElement('script');
      s.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>
    Please enable JavaScript to view the
    <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
  </noscript>
  
  
  
</article>

</main>
<footer class="footer">
  <span>&copy; 2019 <a href="https://blog.bing0ne.com">bing0ne Base</a></span>
  <span>&middot;</span>
  <span>Powered by <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo️️</a>️</span>
  <span>&middot;</span>
  <span>Theme️ <a href="https://github.com/nanxiaobei/hugo-paper" rel="noopener" target="_blank">Paper</a></span>
</footer>
<script src="https://blog.bing0ne.com/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>

